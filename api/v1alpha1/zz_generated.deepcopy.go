//go:build !ignore_autogenerated

/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"k8s.io/api/core/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Auth) DeepCopyInto(out *Auth) {
	*out = *in
	if in.Token != nil {
		in, out := &in.Token, &out.Token
		*out = new(v1.SecretKeySelector)
		(*in).DeepCopyInto(*out)
	}
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = new(v1.SecretKeySelector)
		(*in).DeepCopyInto(*out)
	}
	if in.Password != nil {
		in, out := &in.Password, &out.Password
		*out = new(v1.SecretKeySelector)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Auth.
func (in *Auth) DeepCopy() *Auth {
	if in == nil {
		return nil
	}
	out := new(Auth)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthProxy) DeepCopyInto(out *AuthProxy) {
	*out = *in
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(v1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
	if in.BindPasswordSecret != nil {
		in, out := &in.BindPasswordSecret, &out.BindPasswordSecret
		*out = new(v1.SecretKeySelector)
		(*in).DeepCopyInto(*out)
	}
	out.CA = in.CA
	out.Cert = in.Cert
	out.Key = in.Key
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthProxy.
func (in *AuthProxy) DeepCopy() *AuthProxy {
	if in == nil {
		return nil
	}
	out := new(AuthProxy)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CA) DeepCopyInto(out *CA) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CA.
func (in *CA) DeepCopy() *CA {
	if in == nil {
		return nil
	}
	out := new(CA)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Cert) DeepCopyInto(out *Cert) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Cert.
func (in *Cert) DeepCopy() *Cert {
	if in == nil {
		return nil
	}
	out := new(Cert)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Certificates) DeepCopyInto(out *Certificates) {
	*out = *in
	if in.CA != nil {
		in, out := &in.CA, &out.CA
		*out = new(CA)
		**out = **in
	}
	if in.Cert != nil {
		in, out := &in.Cert, &out.Cert
		*out = new(Cert)
		**out = **in
	}
	if in.Key != nil {
		in, out := &in.Key, &out.Key
		*out = new(Key)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Certificates.
func (in *Certificates) DeepCopy() *Certificates {
	if in == nil {
		return nil
	}
	out := new(Certificates)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CloudEventsReader) DeepCopyInto(out *CloudEventsReader) {
	*out = *in
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(v1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
	if in.Affinity != nil {
		in, out := &in.Affinity, &out.Affinity
		*out = new(v1.Affinity)
		(*in).DeepCopyInto(*out)
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Args != nil {
		in, out := &in.Args, &out.Args
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CloudEventsReader.
func (in *CloudEventsReader) DeepCopy() *CloudEventsReader {
	if in == nil {
		return nil
	}
	out := new(CloudEventsReader)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConfigmapReload) DeepCopyInto(out *ConfigmapReload) {
	*out = *in
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(v1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConfigmapReload.
func (in *ConfigmapReload) DeepCopy() *ConfigmapReload {
	if in == nil {
		return nil
	}
	out := new(ConfigmapReload)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ContentPackPathHTTPConfig) DeepCopyInto(out *ContentPackPathHTTPConfig) {
	*out = *in
	if in.HTTPConfig != nil {
		in, out := &in.HTTPConfig, &out.HTTPConfig
		*out = new(HTTPConfig)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ContentPackPathHTTPConfig.
func (in *ContentPackPathHTTPConfig) DeepCopy() *ContentPackPathHTTPConfig {
	if in == nil {
		return nil
	}
	out := new(ContentPackPathHTTPConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Credentials) DeepCopyInto(out *Credentials) {
	*out = *in
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = new(v1.SecretKeySelector)
		(*in).DeepCopyInto(*out)
	}
	if in.Password != nil {
		in, out := &in.Password, &out.Password
		*out = new(v1.SecretKeySelector)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Credentials.
func (in *Credentials) DeepCopy() *Credentials {
	if in == nil {
		return nil
	}
	out := new(Credentials)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Fluentbit) DeepCopyInto(out *Fluentbit) {
	*out = *in
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(v1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ExtraFields != nil {
		in, out := &in.ExtraFields, &out.ExtraFields
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Aggregator != nil {
		in, out := &in.Aggregator, &out.Aggregator
		*out = new(FluentbitAggregator)
		(*in).DeepCopyInto(*out)
	}
	if in.ConfigmapReload != nil {
		in, out := &in.ConfigmapReload, &out.ConfigmapReload
		*out = new(ConfigmapReload)
		(*in).DeepCopyInto(*out)
	}
	if in.CustomLuaScriptConf != nil {
		in, out := &in.CustomLuaScriptConf, &out.CustomLuaScriptConf
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	in.TLS.DeepCopyInto(&out.TLS)
	if in.AdditionalVolumes != nil {
		in, out := &in.AdditionalVolumes, &out.AdditionalVolumes
		*out = make([]v1.Volume, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.AdditionalVolumeMounts != nil {
		in, out := &in.AdditionalVolumeMounts, &out.AdditionalVolumeMounts
		*out = make([]v1.VolumeMount, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Tolerations != nil {
		in, out := &in.Tolerations, &out.Tolerations
		*out = make([]v1.Toleration, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Affinity != nil {
		in, out := &in.Affinity, &out.Affinity
		*out = new(v1.Affinity)
		(*in).DeepCopyInto(*out)
	}
	if in.Output != nil {
		in, out := &in.Output, &out.Output
		*out = new(OutputFluentbit)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Fluentbit.
func (in *Fluentbit) DeepCopy() *Fluentbit {
	if in == nil {
		return nil
	}
	out := new(Fluentbit)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FluentbitAggregator) DeepCopyInto(out *FluentbitAggregator) {
	*out = *in
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Volume != nil {
		in, out := &in.Volume, &out.Volume
		*out = new(Volume)
		**out = **in
	}
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(v1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ExtraFields != nil {
		in, out := &in.ExtraFields, &out.ExtraFields
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ConfigmapReload != nil {
		in, out := &in.ConfigmapReload, &out.ConfigmapReload
		*out = new(ConfigmapReload)
		(*in).DeepCopyInto(*out)
	}
	if in.CustomLuaScriptConf != nil {
		in, out := &in.CustomLuaScriptConf, &out.CustomLuaScriptConf
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	in.TLS.DeepCopyInto(&out.TLS)
	if in.Tolerations != nil {
		in, out := &in.Tolerations, &out.Tolerations
		*out = make([]v1.Toleration, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Affinity != nil {
		in, out := &in.Affinity, &out.Affinity
		*out = new(v1.Affinity)
		(*in).DeepCopyInto(*out)
	}
	if in.Output != nil {
		in, out := &in.Output, &out.Output
		*out = new(OutputFluentbit)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FluentbitAggregator.
func (in *FluentbitAggregator) DeepCopy() *FluentbitAggregator {
	if in == nil {
		return nil
	}
	out := new(FluentbitAggregator)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FluentbitLokiTLS) DeepCopyInto(out *FluentbitLokiTLS) {
	*out = *in
	in.Certificates.DeepCopyInto(&out.Certificates)
	out.FluentbitTLSParams = in.FluentbitTLSParams
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FluentbitLokiTLS.
func (in *FluentbitLokiTLS) DeepCopy() *FluentbitLokiTLS {
	if in == nil {
		return nil
	}
	out := new(FluentbitLokiTLS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FluentbitTLS) DeepCopyInto(out *FluentbitTLS) {
	*out = *in
	in.TLS.DeepCopyInto(&out.TLS)
	out.FluentbitTLSParams = in.FluentbitTLSParams
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FluentbitTLS.
func (in *FluentbitTLS) DeepCopy() *FluentbitTLS {
	if in == nil {
		return nil
	}
	out := new(FluentbitTLS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FluentbitTLSParams) DeepCopyInto(out *FluentbitTLSParams) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FluentbitTLSParams.
func (in *FluentbitTLSParams) DeepCopy() *FluentbitTLSParams {
	if in == nil {
		return nil
	}
	out := new(FluentbitTLSParams)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Fluentd) DeepCopyInto(out *Fluentd) {
	*out = *in
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(v1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ExtraFields != nil {
		in, out := &in.ExtraFields, &out.ExtraFields
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ConfigmapReload != nil {
		in, out := &in.ConfigmapReload, &out.ConfigmapReload
		*out = new(ConfigmapReload)
		(*in).DeepCopyInto(*out)
	}
	in.TLS.DeepCopyInto(&out.TLS)
	if in.AdditionalVolumeMounts != nil {
		in, out := &in.AdditionalVolumeMounts, &out.AdditionalVolumeMounts
		*out = make([]v1.VolumeMount, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ExcludePath != nil {
		in, out := &in.ExcludePath, &out.ExcludePath
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.AdditionalVolumes != nil {
		in, out := &in.AdditionalVolumes, &out.AdditionalVolumes
		*out = make([]v1.Volume, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Tolerations != nil {
		in, out := &in.Tolerations, &out.Tolerations
		*out = make([]v1.Toleration, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Affinity != nil {
		in, out := &in.Affinity, &out.Affinity
		*out = new(v1.Affinity)
		(*in).DeepCopyInto(*out)
	}
	if in.Output != nil {
		in, out := &in.Output, &out.Output
		*out = new(OutputFluentd)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Fluentd.
func (in *Fluentd) DeepCopy() *Fluentd {
	if in == nil {
		return nil
	}
	out := new(Fluentd)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FluentdLokiTLS) DeepCopyInto(out *FluentdLokiTLS) {
	*out = *in
	in.Certificates.DeepCopyInto(&out.Certificates)
	out.FluentdTLSParams = in.FluentdTLSParams
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FluentdLokiTLS.
func (in *FluentdLokiTLS) DeepCopy() *FluentdLokiTLS {
	if in == nil {
		return nil
	}
	out := new(FluentdLokiTLS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FluentdTLS) DeepCopyInto(out *FluentdTLS) {
	*out = *in
	in.TLS.DeepCopyInto(&out.TLS)
	out.FluentdTLSParams = in.FluentdTLSParams
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FluentdTLS.
func (in *FluentdTLS) DeepCopy() *FluentdTLS {
	if in == nil {
		return nil
	}
	out := new(FluentdTLS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FluentdTLSParams) DeepCopyInto(out *FluentdTLSParams) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FluentdTLSParams.
func (in *FluentdTLSParams) DeepCopy() *FluentdTLSParams {
	if in == nil {
		return nil
	}
	out := new(FluentdTLSParams)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GenerateCerts) DeepCopyInto(out *GenerateCerts) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GenerateCerts.
func (in *GenerateCerts) DeepCopy() *GenerateCerts {
	if in == nil {
		return nil
	}
	out := new(GenerateCerts)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Graylog) DeepCopyInto(out *Graylog) {
	*out = *in
	if in.GraylogResources != nil {
		in, out := &in.GraylogResources, &out.GraylogResources
		*out = new(v1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
	if in.MongoResources != nil {
		in, out := &in.MongoResources, &out.MongoResources
		*out = new(v1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
	if in.InitResources != nil {
		in, out := &in.InitResources, &out.InitResources
		*out = new(v1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
	if in.MongoDBUpgrade != nil {
		in, out := &in.MongoDBUpgrade, &out.MongoDBUpgrade
		*out = new(MongoDBUpgrade)
		**out = **in
	}
	if in.AuthProxy != nil {
		in, out := &in.AuthProxy, &out.AuthProxy
		*out = new(AuthProxy)
		(*in).DeepCopyInto(*out)
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(GraylogTLS)
		(*in).DeepCopyInto(*out)
	}
	if in.OpenSearch != nil {
		in, out := &in.OpenSearch, &out.OpenSearch
		*out = new(OpenSearch)
		(*in).DeepCopyInto(*out)
	}
	if in.Affinity != nil {
		in, out := &in.Affinity, &out.Affinity
		*out = new(v1.Affinity)
		(*in).DeepCopyInto(*out)
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ContentPacks != nil {
		in, out := &in.ContentPacks, &out.ContentPacks
		*out = make([]*ContentPackPathHTTPConfig, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(ContentPackPathHTTPConfig)
				(*in).DeepCopyInto(*out)
			}
		}
	}
	if in.Streams != nil {
		in, out := &in.Streams, &out.Streams
		*out = make([]Stream, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Graylog.
func (in *Graylog) DeepCopy() *Graylog {
	if in == nil {
		return nil
	}
	out := new(Graylog)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GraylogTLS) DeepCopyInto(out *GraylogTLS) {
	*out = *in
	if in.HTTP != nil {
		in, out := &in.HTTP, &out.HTTP
		*out = new(HTTPGraylogTLS)
		(*in).DeepCopyInto(*out)
	}
	if in.Input != nil {
		in, out := &in.Input, &out.Input
		*out = new(InputGraylogTLS)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GraylogTLS.
func (in *GraylogTLS) DeepCopy() *GraylogTLS {
	if in == nil {
		return nil
	}
	out := new(GraylogTLS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HTTPConfig) DeepCopyInto(out *HTTPConfig) {
	*out = *in
	if in.Credentials != nil {
		in, out := &in.Credentials, &out.Credentials
		*out = new(Credentials)
		(*in).DeepCopyInto(*out)
	}
	if in.TLSConfig != nil {
		in, out := &in.TLSConfig, &out.TLSConfig
		*out = new(TLSConfig)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HTTPConfig.
func (in *HTTPConfig) DeepCopy() *HTTPConfig {
	if in == nil {
		return nil
	}
	out := new(HTTPConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HTTPGraylogTLS) DeepCopyInto(out *HTTPGraylogTLS) {
	*out = *in
	if in.GenerateCerts != nil {
		in, out := &in.GenerateCerts, &out.GenerateCerts
		*out = new(GenerateCerts)
		**out = **in
	}
	if in.Cert != nil {
		in, out := &in.Cert, &out.Cert
		*out = new(Cert)
		**out = **in
	}
	if in.Key != nil {
		in, out := &in.Key, &out.Key
		*out = new(Key)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HTTPGraylogTLS.
func (in *HTTPGraylogTLS) DeepCopy() *HTTPGraylogTLS {
	if in == nil {
		return nil
	}
	out := new(HTTPGraylogTLS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *InputGraylogTLS) DeepCopyInto(out *InputGraylogTLS) {
	*out = *in
	in.TLS.DeepCopyInto(&out.TLS)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new InputGraylogTLS.
func (in *InputGraylogTLS) DeepCopy() *InputGraylogTLS {
	if in == nil {
		return nil
	}
	out := new(InputGraylogTLS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Key) DeepCopyInto(out *Key) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Key.
func (in *Key) DeepCopy() *Key {
	if in == nil {
		return nil
	}
	out := new(Key)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LoggingService) DeepCopyInto(out *LoggingService) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LoggingService.
func (in *LoggingService) DeepCopy() *LoggingService {
	if in == nil {
		return nil
	}
	out := new(LoggingService)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LoggingService) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LoggingServiceCondition) DeepCopyInto(out *LoggingServiceCondition) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LoggingServiceCondition.
func (in *LoggingServiceCondition) DeepCopy() *LoggingServiceCondition {
	if in == nil {
		return nil
	}
	out := new(LoggingServiceCondition)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LoggingServiceList) DeepCopyInto(out *LoggingServiceList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LoggingService, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LoggingServiceList.
func (in *LoggingServiceList) DeepCopy() *LoggingServiceList {
	if in == nil {
		return nil
	}
	out := new(LoggingServiceList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LoggingServiceList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LoggingServiceParameters) DeepCopyInto(out *LoggingServiceParameters) {
	*out = *in
	out.Release = in.Release
	in.Values.DeepCopyInto(&out.Values)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LoggingServiceParameters.
func (in *LoggingServiceParameters) DeepCopy() *LoggingServiceParameters {
	if in == nil {
		return nil
	}
	out := new(LoggingServiceParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LoggingServiceSpec) DeepCopyInto(out *LoggingServiceSpec) {
	*out = *in
	if in.Graylog != nil {
		in, out := &in.Graylog, &out.Graylog
		*out = new(Graylog)
		(*in).DeepCopyInto(*out)
	}
	if in.Fluentd != nil {
		in, out := &in.Fluentd, &out.Fluentd
		*out = new(Fluentd)
		(*in).DeepCopyInto(*out)
	}
	if in.Fluentbit != nil {
		in, out := &in.Fluentbit, &out.Fluentbit
		*out = new(Fluentbit)
		(*in).DeepCopyInto(*out)
	}
	if in.CloudEventsReader != nil {
		in, out := &in.CloudEventsReader, &out.CloudEventsReader
		*out = new(CloudEventsReader)
		(*in).DeepCopyInto(*out)
	}
	if in.MonitoringAgentLoggingPlugin != nil {
		in, out := &in.MonitoringAgentLoggingPlugin, &out.MonitoringAgentLoggingPlugin
		*out = new(MonitoringAgentLoggingPlugin)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LoggingServiceSpec.
func (in *LoggingServiceSpec) DeepCopy() *LoggingServiceSpec {
	if in == nil {
		return nil
	}
	out := new(LoggingServiceSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LoggingServiceStatus) DeepCopyInto(out *LoggingServiceStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]LoggingServiceCondition, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LoggingServiceStatus.
func (in *LoggingServiceStatus) DeepCopy() *LoggingServiceStatus {
	if in == nil {
		return nil
	}
	out := new(LoggingServiceStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LokiFluentbit) DeepCopyInto(out *LokiFluentbit) {
	*out = *in
	if in.Auth != nil {
		in, out := &in.Auth, &out.Auth
		*out = new(Auth)
		(*in).DeepCopyInto(*out)
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(FluentbitLokiTLS)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LokiFluentbit.
func (in *LokiFluentbit) DeepCopy() *LokiFluentbit {
	if in == nil {
		return nil
	}
	out := new(LokiFluentbit)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LokiFluentd) DeepCopyInto(out *LokiFluentd) {
	*out = *in
	if in.Auth != nil {
		in, out := &in.Auth, &out.Auth
		*out = new(Auth)
		(*in).DeepCopyInto(*out)
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(FluentdLokiTLS)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LokiFluentd.
func (in *LokiFluentd) DeepCopy() *LokiFluentd {
	if in == nil {
		return nil
	}
	out := new(LokiFluentd)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MongoDBUpgrade) DeepCopyInto(out *MongoDBUpgrade) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MongoDBUpgrade.
func (in *MongoDBUpgrade) DeepCopy() *MongoDBUpgrade {
	if in == nil {
		return nil
	}
	out := new(MongoDBUpgrade)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MonitoringAgentLoggingPlugin) DeepCopyInto(out *MonitoringAgentLoggingPlugin) {
	*out = *in
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(v1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MonitoringAgentLoggingPlugin.
func (in *MonitoringAgentLoggingPlugin) DeepCopy() *MonitoringAgentLoggingPlugin {
	if in == nil {
		return nil
	}
	out := new(MonitoringAgentLoggingPlugin)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenSearch) DeepCopyInto(out *OpenSearch) {
	*out = *in
	if in.HTTPConfig != nil {
		in, out := &in.HTTPConfig, &out.HTTPConfig
		*out = new(HTTPConfig)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenSearch.
func (in *OpenSearch) DeepCopy() *OpenSearch {
	if in == nil {
		return nil
	}
	out := new(OpenSearch)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OutputFluentbit) DeepCopyInto(out *OutputFluentbit) {
	*out = *in
	if in.Loki != nil {
		in, out := &in.Loki, &out.Loki
		*out = new(LokiFluentbit)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OutputFluentbit.
func (in *OutputFluentbit) DeepCopy() *OutputFluentbit {
	if in == nil {
		return nil
	}
	out := new(OutputFluentbit)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OutputFluentd) DeepCopyInto(out *OutputFluentd) {
	*out = *in
	if in.Loki != nil {
		in, out := &in.Loki, &out.Loki
		*out = new(LokiFluentd)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OutputFluentd.
func (in *OutputFluentd) DeepCopy() *OutputFluentd {
	if in == nil {
		return nil
	}
	out := new(OutputFluentd)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Release) DeepCopyInto(out *Release) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Release.
func (in *Release) DeepCopy() *Release {
	if in == nil {
		return nil
	}
	out := new(Release)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Stream) DeepCopyInto(out *Stream) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Stream.
func (in *Stream) DeepCopy() *Stream {
	if in == nil {
		return nil
	}
	out := new(Stream)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TLS) DeepCopyInto(out *TLS) {
	*out = *in
	if in.GenerateCerts != nil {
		in, out := &in.GenerateCerts, &out.GenerateCerts
		*out = new(GenerateCerts)
		**out = **in
	}
	in.Certificates.DeepCopyInto(&out.Certificates)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TLS.
func (in *TLS) DeepCopy() *TLS {
	if in == nil {
		return nil
	}
	out := new(TLS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TLSConfig) DeepCopyInto(out *TLSConfig) {
	*out = *in
	if in.CA != nil {
		in, out := &in.CA, &out.CA
		*out = new(v1.SecretKeySelector)
		(*in).DeepCopyInto(*out)
	}
	if in.Cert != nil {
		in, out := &in.Cert, &out.Cert
		*out = new(v1.SecretKeySelector)
		(*in).DeepCopyInto(*out)
	}
	if in.Key != nil {
		in, out := &in.Key, &out.Key
		*out = new(v1.SecretKeySelector)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TLSConfig.
func (in *TLSConfig) DeepCopy() *TLSConfig {
	if in == nil {
		return nil
	}
	out := new(TLSConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Volume) DeepCopyInto(out *Volume) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Volume.
func (in *Volume) DeepCopy() *Volume {
	if in == nil {
		return nil
	}
	out := new(Volume)
	in.DeepCopyInto(out)
	return out
}
